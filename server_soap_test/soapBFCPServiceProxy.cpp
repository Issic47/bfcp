/* soapBFCPServiceProxy.cpp
   Generated by gSOAP 2.8.21 from server.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#include "soapBFCPServiceProxy.h"

BFCPServiceProxy::BFCPServiceProxy()
{	BFCPServiceProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

BFCPServiceProxy::BFCPServiceProxy(const struct soap &_soap) : soap(_soap)
{ }

BFCPServiceProxy::BFCPServiceProxy(const char *url)
{	BFCPServiceProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
	soap_endpoint = url;
}

BFCPServiceProxy::BFCPServiceProxy(soap_mode iomode)
{	BFCPServiceProxy_init(iomode, iomode);
}

BFCPServiceProxy::BFCPServiceProxy(const char *url, soap_mode iomode)
{	BFCPServiceProxy_init(iomode, iomode);
	soap_endpoint = url;
}

BFCPServiceProxy::BFCPServiceProxy(soap_mode imode, soap_mode omode)
{	BFCPServiceProxy_init(imode, omode);
}

BFCPServiceProxy::~BFCPServiceProxy()
{ }

void BFCPServiceProxy::BFCPServiceProxy_init(soap_mode imode, soap_mode omode)
{	soap_imode(this, imode);
	soap_omode(this, omode);
	soap_endpoint = NULL;
	static const struct Namespace namespaces[] =
{
	{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
	{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
	{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
	{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
	{"ns", "urn:BFCPService", NULL, NULL},
	{NULL, NULL, NULL, NULL}
};
	soap_set_namespaces(this, namespaces);
}

void BFCPServiceProxy::destroy()
{	soap_destroy(this);
	soap_end(this);
}

void BFCPServiceProxy::reset()
{	destroy();
	soap_done(this);
	soap_initialize(this);
	BFCPServiceProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

void BFCPServiceProxy::soap_noheader()
{	this->header = NULL;
}

const SOAP_ENV__Header *BFCPServiceProxy::soap_header()
{	return this->header;
}

const SOAP_ENV__Fault *BFCPServiceProxy::soap_fault()
{	return this->fault;
}

const char *BFCPServiceProxy::soap_fault_string()
{	return *soap_faultstring(this);
}

const char *BFCPServiceProxy::soap_fault_detail()
{	return *soap_faultdetail(this);
}

int BFCPServiceProxy::soap_close_socket()
{	return soap_closesock(this);
}

int BFCPServiceProxy::soap_force_close_socket()
{	return soap_force_closesock(this);
}

void BFCPServiceProxy::soap_print_fault(FILE *fd)
{	::soap_print_fault(this, fd);
}

#ifndef WITH_LEAN
#ifndef WITH_COMPAT
void BFCPServiceProxy::soap_stream_fault(std::ostream& os)
{	::soap_stream_fault(this, os);
}
#endif

char *BFCPServiceProxy::soap_sprint_fault(char *buf, size_t len)
{	return ::soap_sprint_fault(this, buf, len);
}
#endif

int BFCPServiceProxy::start(const char *endpoint, const char *soap_action, enum ns__AddrFamily af, unsigned short port, bool enbaleConnectionThread, int workThreadNum, double userObsoletedTime, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__start soap_tmp_ns__start;
	struct ns__startResponse *soap_tmp_ns__startResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__start.af = af;
	soap_tmp_ns__start.port = port;
	soap_tmp_ns__start.enbaleConnectionThread = enbaleConnectionThread;
	soap_tmp_ns__start.workThreadNum = workThreadNum;
	soap_tmp_ns__start.userObsoletedTime = userObsoletedTime;
	soap_serializeheader(soap);
	soap_serialize_ns__start(soap, &soap_tmp_ns__start);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__start(soap, &soap_tmp_ns__start, "ns:start", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__start(soap, &soap_tmp_ns__start, "ns:start", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__startResponse = soap_get_ns__startResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__startResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__startResponse->errorCode)
		*errorCode = *soap_tmp_ns__startResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::stop(const char *endpoint, const char *soap_action, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__stop soap_tmp_ns__stop;
	struct ns__stopResponse *soap_tmp_ns__stopResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_serializeheader(soap);
	soap_serialize_ns__stop(soap, &soap_tmp_ns__stop);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__stop(soap, &soap_tmp_ns__stop, "ns:stop", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__stop(soap, &soap_tmp_ns__stop, "ns:stop", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__stopResponse = soap_get_ns__stopResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__stopResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__stopResponse->errorCode)
		*errorCode = *soap_tmp_ns__stopResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::send_quit(const char *endpoint, const char *soap_action)
{	struct soap *soap = this;
	struct ns__quit soap_tmp_ns__quit;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_serializeheader(soap);
	soap_serialize_ns__quit(soap, &soap_tmp_ns__quit);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__quit(soap, &soap_tmp_ns__quit, "ns:quit", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__quit(soap, &soap_tmp_ns__quit, "ns:quit", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int BFCPServiceProxy::recv_quit(struct ns__quit& tmp)
{	struct soap *soap = this;

	struct ns__quit *_param_1 = &tmp;
	soap_default_ns__quit(soap, _param_1);
	soap_begin(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	soap_get_ns__quit(soap, _param_1, "ns:quit", NULL);
	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
		soap->error = SOAP_OK;
	if (soap->error
	 || soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int BFCPServiceProxy::addConference(const char *endpoint, const char *soap_action, unsigned int conferenceID, unsigned short maxFloorRequest, enum ns__Policy policy, double timeForChairAction, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__addConference soap_tmp_ns__addConference;
	struct ns__addConferenceResponse *soap_tmp_ns__addConferenceResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__addConference.conferenceID = conferenceID;
	soap_tmp_ns__addConference.maxFloorRequest = maxFloorRequest;
	soap_tmp_ns__addConference.policy = policy;
	soap_tmp_ns__addConference.timeForChairAction = timeForChairAction;
	soap_serializeheader(soap);
	soap_serialize_ns__addConference(soap, &soap_tmp_ns__addConference);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__addConference(soap, &soap_tmp_ns__addConference, "ns:addConference", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__addConference(soap, &soap_tmp_ns__addConference, "ns:addConference", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__addConferenceResponse = soap_get_ns__addConferenceResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__addConferenceResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__addConferenceResponse->errorCode)
		*errorCode = *soap_tmp_ns__addConferenceResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::removeConference(const char *endpoint, const char *soap_action, unsigned int conferenceID, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__removeConference soap_tmp_ns__removeConference;
	struct ns__removeConferenceResponse *soap_tmp_ns__removeConferenceResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__removeConference.conferenceID = conferenceID;
	soap_serializeheader(soap);
	soap_serialize_ns__removeConference(soap, &soap_tmp_ns__removeConference);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__removeConference(soap, &soap_tmp_ns__removeConference, "ns:removeConference", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__removeConference(soap, &soap_tmp_ns__removeConference, "ns:removeConference", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__removeConferenceResponse = soap_get_ns__removeConferenceResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__removeConferenceResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__removeConferenceResponse->errorCode)
		*errorCode = *soap_tmp_ns__removeConferenceResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::modifyConference(const char *endpoint, const char *soap_action, unsigned int conferenceID, unsigned short maxFloorRequest, enum ns__Policy policy, double timeForChairAction, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__modifyConference soap_tmp_ns__modifyConference;
	struct ns__modifyConferenceResponse *soap_tmp_ns__modifyConferenceResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__modifyConference.conferenceID = conferenceID;
	soap_tmp_ns__modifyConference.maxFloorRequest = maxFloorRequest;
	soap_tmp_ns__modifyConference.policy = policy;
	soap_tmp_ns__modifyConference.timeForChairAction = timeForChairAction;
	soap_serializeheader(soap);
	soap_serialize_ns__modifyConference(soap, &soap_tmp_ns__modifyConference);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__modifyConference(soap, &soap_tmp_ns__modifyConference, "ns:modifyConference", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__modifyConference(soap, &soap_tmp_ns__modifyConference, "ns:modifyConference", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__modifyConferenceResponse = soap_get_ns__modifyConferenceResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__modifyConferenceResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__modifyConferenceResponse->errorCode)
		*errorCode = *soap_tmp_ns__modifyConferenceResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::addFloor(const char *endpoint, const char *soap_action, unsigned int conferenceID, unsigned short floorID, unsigned short maxGrantedNum, double maxHoldingTime, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__addFloor soap_tmp_ns__addFloor;
	struct ns__addFloorResponse *soap_tmp_ns__addFloorResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__addFloor.conferenceID = conferenceID;
	soap_tmp_ns__addFloor.floorID = floorID;
	soap_tmp_ns__addFloor.maxGrantedNum = maxGrantedNum;
	soap_tmp_ns__addFloor.maxHoldingTime = maxHoldingTime;
	soap_serializeheader(soap);
	soap_serialize_ns__addFloor(soap, &soap_tmp_ns__addFloor);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__addFloor(soap, &soap_tmp_ns__addFloor, "ns:addFloor", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__addFloor(soap, &soap_tmp_ns__addFloor, "ns:addFloor", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__addFloorResponse = soap_get_ns__addFloorResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__addFloorResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__addFloorResponse->errorCode)
		*errorCode = *soap_tmp_ns__addFloorResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::removeFloor(const char *endpoint, const char *soap_action, unsigned int conferenceID, unsigned short floorID, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__removeFloor soap_tmp_ns__removeFloor;
	struct ns__removeFloorResponse *soap_tmp_ns__removeFloorResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__removeFloor.conferenceID = conferenceID;
	soap_tmp_ns__removeFloor.floorID = floorID;
	soap_serializeheader(soap);
	soap_serialize_ns__removeFloor(soap, &soap_tmp_ns__removeFloor);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__removeFloor(soap, &soap_tmp_ns__removeFloor, "ns:removeFloor", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__removeFloor(soap, &soap_tmp_ns__removeFloor, "ns:removeFloor", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__removeFloorResponse = soap_get_ns__removeFloorResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__removeFloorResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__removeFloorResponse->errorCode)
		*errorCode = *soap_tmp_ns__removeFloorResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::modifyFloor(const char *endpoint, const char *soap_action, unsigned int conferenceID, unsigned short floorID, unsigned short maxGrantedNum, double maxHoldingTime, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__modifyFloor soap_tmp_ns__modifyFloor;
	struct ns__modifyFloorResponse *soap_tmp_ns__modifyFloorResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__modifyFloor.conferenceID = conferenceID;
	soap_tmp_ns__modifyFloor.floorID = floorID;
	soap_tmp_ns__modifyFloor.maxGrantedNum = maxGrantedNum;
	soap_tmp_ns__modifyFloor.maxHoldingTime = maxHoldingTime;
	soap_serializeheader(soap);
	soap_serialize_ns__modifyFloor(soap, &soap_tmp_ns__modifyFloor);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__modifyFloor(soap, &soap_tmp_ns__modifyFloor, "ns:modifyFloor", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__modifyFloor(soap, &soap_tmp_ns__modifyFloor, "ns:modifyFloor", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__modifyFloorResponse = soap_get_ns__modifyFloorResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__modifyFloorResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__modifyFloorResponse->errorCode)
		*errorCode = *soap_tmp_ns__modifyFloorResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::addUser(const char *endpoint, const char *soap_action, unsigned int conferenceID, unsigned short userID, std::string userName, std::string userURI, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__addUser soap_tmp_ns__addUser;
	struct ns__addUserResponse *soap_tmp_ns__addUserResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__addUser.conferenceID = conferenceID;
	soap_tmp_ns__addUser.userID = userID;
	soap_tmp_ns__addUser.userName = userName;
	soap_tmp_ns__addUser.userURI = userURI;
	soap_serializeheader(soap);
	soap_serialize_ns__addUser(soap, &soap_tmp_ns__addUser);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__addUser(soap, &soap_tmp_ns__addUser, "ns:addUser", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__addUser(soap, &soap_tmp_ns__addUser, "ns:addUser", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__addUserResponse = soap_get_ns__addUserResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__addUserResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__addUserResponse->errorCode)
		*errorCode = *soap_tmp_ns__addUserResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::removeUser(const char *endpoint, const char *soap_action, unsigned int conferenceID, unsigned short userID, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__removeUser soap_tmp_ns__removeUser;
	struct ns__removeUserResponse *soap_tmp_ns__removeUserResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__removeUser.conferenceID = conferenceID;
	soap_tmp_ns__removeUser.userID = userID;
	soap_serializeheader(soap);
	soap_serialize_ns__removeUser(soap, &soap_tmp_ns__removeUser);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__removeUser(soap, &soap_tmp_ns__removeUser, "ns:removeUser", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__removeUser(soap, &soap_tmp_ns__removeUser, "ns:removeUser", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__removeUserResponse = soap_get_ns__removeUserResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__removeUserResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__removeUserResponse->errorCode)
		*errorCode = *soap_tmp_ns__removeUserResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::setChair(const char *endpoint, const char *soap_action, unsigned int conferenceID, unsigned short floorID, unsigned short userID, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__setChair soap_tmp_ns__setChair;
	struct ns__setChairResponse *soap_tmp_ns__setChairResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__setChair.conferenceID = conferenceID;
	soap_tmp_ns__setChair.floorID = floorID;
	soap_tmp_ns__setChair.userID = userID;
	soap_serializeheader(soap);
	soap_serialize_ns__setChair(soap, &soap_tmp_ns__setChair);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__setChair(soap, &soap_tmp_ns__setChair, "ns:setChair", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__setChair(soap, &soap_tmp_ns__setChair, "ns:setChair", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__setChairResponse = soap_get_ns__setChairResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__setChairResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__setChairResponse->errorCode)
		*errorCode = *soap_tmp_ns__setChairResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::removeChair(const char *endpoint, const char *soap_action, unsigned int conferenceID, unsigned short floorID, enum ns__ErrorCode *errorCode)
{	struct soap *soap = this;
	struct ns__removeChair soap_tmp_ns__removeChair;
	struct ns__removeChairResponse *soap_tmp_ns__removeChairResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__removeChair.conferenceID = conferenceID;
	soap_tmp_ns__removeChair.floorID = floorID;
	soap_serializeheader(soap);
	soap_serialize_ns__removeChair(soap, &soap_tmp_ns__removeChair);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__removeChair(soap, &soap_tmp_ns__removeChair, "ns:removeChair", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__removeChair(soap, &soap_tmp_ns__removeChair, "ns:removeChair", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!errorCode)
		return soap_closesock(soap);
	soap_default_ns__ErrorCode(soap, errorCode);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__removeChairResponse = soap_get_ns__removeChairResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns__removeChairResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (errorCode && soap_tmp_ns__removeChairResponse->errorCode)
		*errorCode = *soap_tmp_ns__removeChairResponse->errorCode;
	return soap_closesock(soap);
}

int BFCPServiceProxy::getConferenceIDs(const char *endpoint, const char *soap_action, ns__ConferenceListResult *result)
{	struct soap *soap = this;
	struct ns__getConferenceIDs soap_tmp_ns__getConferenceIDs;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_serializeheader(soap);
	soap_serialize_ns__getConferenceIDs(soap, &soap_tmp_ns__getConferenceIDs);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__getConferenceIDs(soap, &soap_tmp_ns__getConferenceIDs, "ns:getConferenceIDs", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__getConferenceIDs(soap, &soap_tmp_ns__getConferenceIDs, "ns:getConferenceIDs", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!result)
		return soap_closesock(soap);
	result->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	result->soap_get(soap, "", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int BFCPServiceProxy::getConferenceInfo(const char *endpoint, const char *soap_action, unsigned int conferenceID, ns__ConferenceInfoResult *result)
{	struct soap *soap = this;
	struct ns__getConferenceInfo soap_tmp_ns__getConferenceInfo;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:8011";
	soap_begin(soap);
	soap->encodingStyle = "";
	soap_tmp_ns__getConferenceInfo.conferenceID = conferenceID;
	soap_serializeheader(soap);
	soap_serialize_ns__getConferenceInfo(soap, &soap_tmp_ns__getConferenceInfo);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__getConferenceInfo(soap, &soap_tmp_ns__getConferenceInfo, "ns:getConferenceInfo", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__getConferenceInfo(soap, &soap_tmp_ns__getConferenceInfo, "ns:getConferenceInfo", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!result)
		return soap_closesock(soap);
	result->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	result->soap_get(soap, "", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
/* End of client proxy code */
